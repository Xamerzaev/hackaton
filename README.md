# powerbank
Этот проект является отправной точкой для создания нового бэкэнд-проекта на Django. Он основан на фреймворке DRF.

# Сведения о разработке проекта

## Структура приложений
Все приложения находятся в папке `powerbank/apps`. Проект использует собственную команду `startapp`. Дополнительную информацию можно найти в файле `powerbank/management/commands/startapp.py`.

Команда инициализирует новое приложение с следующими особенностями:
- Папку `models`, вместо общего файла `models.py`, который создается командой `startapp` по умолчанию в Django. Это позволяет разделять модели по их назначению и упрощает структуру проекта.
- Папку `views`, соответствующую вышеуказанному обоснованию создания папки `models`.
- Папку `serializers`, соответствующую вышеуказанному обоснованию создания папки `models`.

Остальные файлы и папки аналогичны тому, как делает Django (например, `admin.py`, `apps.py`).

Эта команда гарантирует, что приложения добавляются в папку `apps` и инициализируются в соответствии с настройками проекта. Чтобы добавить новое приложение, выполните следующую команду:
```bash
$ python manage.py startapp <имя_приложения>
```
Затем добавьте приложение в список `INSTALLED_APPS` в файле `config/base.py`, например:
```python
INSTALLED_APPS = [
    ...
    'powerbank.apps.<имя_приложения>.apps.<ИмяПриложения_с_заглавной_буквы>Config',
    ...
]
```
Например, если ваше имя приложения - `foo`, то это будет выглядеть так:
```python
INSTALLED_APPS = [
    ...
    'powerbank.apps.foo.apps.FooConfig',
    ...
]
```

Рекомендуется включать полную конфигурацию при добавлении приложения в список `INSTALLED_APPS`. Это поддерживает согласованность при использовании сигналов.

## Настройки

Для классовых настроек проект использует [`django-configurations`](https://django-configurations.readthedocs.io/en/stable/). Доступны две конфигурации: `Dev` и `Prod`. Основные настройки находятся в файле `config/base.py`, `Dev` - в файле `config/dev.py`, а `Prod` - в файле `config/prod.py`.

Вы можете использовать переменную окружения `DJANGO_CONFIGURATION` для переключения между конфигурациями. По умолчанию используются настройки `Dev`.

### Переменные окружения
Большинство настроек в проекте основаны на переменных окружения. У вас есть несколько вариантов их использования:
- Установить их в файле `.env` в корне проекта, там, где находится этот файл `README.md`. Вы можете обратиться к файлу `.env.template` для доступных опций и легко создать свой файл конфигурации, используя его.
- Установить их непосредственно через переменные окружения.
- Установить их во время выполнения Docker/Kubernetes с использованием файла `.env`. Большая часть настроек остается такой же, за исключением того, что вам придется избавиться от комментариев в файле `.env.template` при создании файла `.env`.

Вы все равно можете запустить проект, не создавая ни одного из этих файлов, так как для большинства необходимых настроек предусмотрены значения по умолчанию. Однако вам нужно настроить экземпляры базы данных, RabbitMQ (в случае необходимости использования Celery) и убедиться, что настройки соответствуют настройкам, используемым по умолчанию в конфигурациях. Рекомендуется всегда иметь файл `.env` для управления этими настройками.

ПРИМЕЧАНИЕ: Значения для `POWERBANK_PASSWORD_RESET_URL` и `POWERBANK_EMAIL_VERIFICATION_URL` должны быть установлены для правильной работы этих потоков. Они обеспечивают перенаправление на URL-адреса на стороне фронтенда для сброса пароля и верификации по электронной почте.

Проверка по электронной почте может быть страницей, которая получает и обрабатывает ссылку, а также отправляет соответствующий запрос на бэкенд для верификации по электронной почте, или страницей, которая ожидает явного подтверждения со стороны пользователя.

## Документация
Проект использует `drf-yasg` для автоматического создания документации для API-точек, но сгенерированная документация не очень хороша, поэтому в этом проекте используется собственная схема для управления документацией.

Детали для каждой точки доступа управляются с использованием класса. Например, приложение `accounts` поддерживает обновление профиля, поэтому класс `ProfileUpdate` используется для управления документацией для этой точки доступа. О

н выглядит примерно так:

```python
class ProfileUpdate:
    desc = f"""
Profile Update - это точка доступа API для обновления профиля,
связанного с конкретным пользователем.

С помощью этой точки доступа вы можете сделать запрос PATCH для обновления профиля
связанного с любым пользователем. {fields_to_md(ProfileCreateUpdateSerializer.fields_names)}
это поля, которые в настоящее время можно обновить.
    """  # noqa

    responses = {
        "200": openapi.Response(
            description="OK",
            examples=profile_update_200_example,
            schema=UserInfoSerializer,
        ),
        "401": openapi.Response(
            description="Unauthorized", examples=profile_update_401_example
        ),
        "403": openapi.Response(
            description="Permission Denied",
            examples=profile_update_403_example,
        ),
    }

    code_examples = [{"lang": "Bash", "source": profile_update_curl}]

    swagger_setup = {
        "operation_id": "Profile Update",
        "operation_description": desc,
        "request_body": ProfileCreateUpdateSerializer,
        "responses": responses,
        "code_examples": code_examples,
    }
```

Примеры взяты из `config/examples` и выглядят примерно так:

```python
profile_update_200_example = {
    "application/json": {
        "id": 1,
        "name": "Test developer",
        "profile_pic": "/some_pic.jpg"
    },
}

profile_update_401_example = {
    "application/json": {
        "error": "NotAuthenticated",
        "detail": "Incorrect authentication credentials.",  # noqa
    }
}

profile_update_403_example = {
    "application/json": {
        "error": "PermissionDenied",
        "detail": "You do not have permission to perform this action."
    }
}
```

После настройки класса вы можете использовать декоратор `swagger_auto_schema`, чтобы вставить спецификацию в представление.

```python
@method_decorator(
    swagger_auto_schema(**ProfileUpdate.swagger_setup), "partial_update"
)
class ProfileViewSet(UpdateModelMixin, PsqMixin, GenericViewSet):
    ...
```

В приведенном выше примере класс `ProfileUpdate`, объявленный ранее, используется для вставки этих настроек в действие `partial_update`.

## Представления

Проект настроен на использование [`GenericViewSet`](https://www.django-rest-framework.org/api-guide/viewsets/#genericviewset), а также использует различные [`mixins`](https://www.django-rest-framework.org/api-guide/generic-views/#mixins) для предоставления действий `create`, `retrieve`, `update` и `destroy`. Вы можете настраивать пользовательские действия для всего остального, что вам может понадобиться.

Представления также используют [`PsqMixin`](https://github.com/drf-psq/drf-psq#1-psqmixin-class), чтобы настроить различные сериализаторы и разрешения для действий. Сериализаторы берутся из папки `serializers`, а разрешения - из папки `permissions` (или файла, по вашему усмотрению).

## Маршрутизаторы
`GenericViewSet` автоматически настраивает URL-адреса на основе используемых смешиваний, а также добавляет пользовательские действия как URL-адреса. Поэтому у нас есть файл `urls/versioned_urls.py`, который использует [`SimpleRouter`](https://www.django-rest-framework.org/api-guide/routers/#simplerouter), чтобы добавить эти представления и подключить их к разным точкам доступа.

### Версионирование
Версия берется из переменных окружения и может быть установлена в файле `.env`. Для добавления и поддержки разных версий можно иметь разные списки `urls` в файле `urls/versioned_urls.py`, затем обновлять переменную окружения для установки последней версии по умолчанию. Вы можете вручную включать другие версии в `urls/__init__.py`, как только они потребуются.

## База данных
Проект поддерживает PostgreSQL, PostGIS, MySQL, MySQL (GIS), Oracle, Oracle (GIS), Redshift, CockroachDB и SQLite. Вы можете обратиться к [этой таблице](https://github.com/jazzband/dj-database-url#url-schema), чтобы узнать подробности о создании URL для вашей базы данных.

# Развертывание проекта
Проект содержит готовый к развертыванию `Dockerfile`. См. `Docker/Dockerfile.web` и `Docker/Dockerfile.celery` для получения дополнительных сведений. Вы можете использовать эти Dockerfile с `docker-compose` или `kubernetes` для развертывания проекта.

Dockerfile использует `uwsgi` для запуска проекта, что позволяет обслуживать статические и медиа файлы непосредственно из вашего контейнера.

Поддержка для `kubernetes` пока не реализована, но планируется в скором времени.